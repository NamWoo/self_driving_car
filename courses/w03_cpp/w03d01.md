***3주차 1일짜 20190527 수업***

***20190527 마지막업데이트***

# Week 3 - Day 1 - C++

>**별딱지! 요약 오늘 중요한거 정리**
>>


[독하게 시작하는 c 프로그래밍 15장 변수와 상수 고급이론 강좌](https://www.inflearn.com/course/%EB%8F%85%ED%95%98%EA%B2%8C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-c-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/#)

https://www.youtube.com/watch?v=IT3iEdnwsRs

---

## intro

항상 생각을 해라. 팀이, 내가 쓰는 기술이 당장 대체 될 수 있다는 것을. 하지만 C, C++ 유망한 언어, Python 도. 

* C 잘하면 좋고
* C++ 기본만 알면 좋고, 일로 할꺼면 잘하고
* Python 빅데이터 처리, 적합한 언어.

## 시작

### 1장의 핵심개념
ㅇ
* 인스턴스
  * 지금까지 배웠던 변수를 객체라는 다른 형식으로 다루는 것
* auto
  * 초기값을 자료형에 맞춰 선언하는 인스턴스의 자료형을 자동으로 결정한다.
* 참조형 변수
  * 포인터의 오류를 줄여주는 자료 다루기 방법
* 범위 기반 for
  * 특정조건 없이도 반복문을 사용하도록 도와준다.

설명

* 인스턴스
 
* 스트럭트 
  * 자료구조 모아놓은 것
* 클래스
  * 스트럭트의 자료구조 + 함수들(맴버, 맴버데이터, 맴버함수)

스트럭트에서 자료만 꺼내썼는데

클래스 자료 넣다 뺐다 뿐만 아니라 시킬 수도 있다. 왜냐? 함수도 가지고 있으니까.

초기화까지 들어가면 정의한다.
초기화 안하면 선언한다.

스텍 안에 스코프 라이프타임 어트리뷰트,

* 스코프 어디에서 어디까지 보이느냐
* 라이프타임 언제태어나서 언제 죽느냐, 메모리에 언제 나타났따가 언제 삭제되느냐

지역은 스코프


```
.TEXT

.DATA

.BSS
.HEAP
.STACK
```

* TEXT
  * 명령어 인스트럭션
* DATA
  * 초기화된 전역변수
  * 스타팅으로 지정된 초기화된 지역변수
* BSS 위에꺼에 초기화되지 않은거
  * 전역변수, 지역변수인데 초기화되지 않은 것.
* HEAP
  * 동적할당한 것들 멜롭, 10바이트주면 보이트포인트주면 케스트로 사용하는..  여기 잡하는 것들은 원래 프로그램에 있던 애들이 아니다. 실행하는 와중에. 맬롭하면 잡하는.
  * 힙은 아래로
    * 힙과 스택은 거리가 멀어서 한 없이 못 올라가게 제한을 둔다. 
* STACK
  * 프로그램, 실행파일로 있을 때는 없다가 
  * 스택은 위로
    * 함수호출
    * 컴파일러 마다 다르다 '매개변수쓸때'
    * 지역변수요! 라고 말해서 틀려주길 바랬다.

포인터 변수, 포인터 상수. 다르다! 

인트 별표 p  
p 피는 포인터 변수.

지역변수와 전역변수의 차이는 스코프.

스택에 잡하는 애들은 `오토변수`다!

C 중에 거의 잘 쓰지 않는 키워드 
* `go to`
* `auto`

하지만 스택에 잡히는 것이 오토변수

스택이 있다는 말은 이미 실행되고 있다는 말.
위에 스택 빼고는 실행파일에 온 것이다. 실행파일이 하드디스크에 있다가 메모리에 올라갔다. 올라갔을 때 모습이 위에. 


* = 어싸인
* 왼쪽 변수
* 오른쪽 변수, 상수

pc, 암 리틀인디안. 사용.
1000  01  78    12345687
1001  00  56
1002  00  34
1003  00  아래서 부터  00:00:00:01 리틀인디안

32비트 시스템, 인트가 4바이트

작은 숫자가 짤리는 위치에 와! 리틀인디안
큰 숫자가 짤리는 위치에 와! 빅인디안



도장을 찍어서 만들어진, 인스턴스?

데이터 타입, 그것을 가리키는 이름, c++에는 확장해서 클래스

인간 남창호

인간 클래스, 남창호 하나의 인간.


#### auto

스택에 자동으로 할당, 됐다가 자동으로 사라지는.
언제 할당? 함수호출하면. 오토변수가 속해있는 함수

원래 씨에 있었는데 유명무실화 C 90년 버전 쓴다. 거기다 조금 알파 더한게 99년 버전.
for (int i=0;) 이게 c99

c++도 비슷하다 03년 표준화 03 04 08 11. 버전. 
저자는 11년버전.

컴파일 따라 달라지는 것.

auto. c++11이 c 에서 가져와서 새로운것으로 만들어 버렸다.

#### 참조형변수

포인터 어려우니까 쓰기 쉽게하자 해서 나온게 참조형변수, 전체는 포인터다. 변수 쓰듯이 쓸 수 있다. 

#### 범위기반 for

auto 가져다 쓴거

### Hello World 로 본 C++

\>> 리다이렉션 의미

출력을 화면에 할 것을 텍스트로 방향을 바꾼 것. 

echo "hello world" >> test.txt

리다이렉션 오퍼레이터.

std::cout << "hellow, world" << std::endl; 

"hellow, world" 가 cout 으로 

#### 스코프가 아니다!

바깥에서 안은 안보인다. 안에서 밖은 보인다.
```
int func()
{
  int i =11;
  {
    static int i = 1;
  }

}
```
스코프가 달라서.. 찾을 수 없다. 

* std:: 네임스페이스, 스코프에서 이 스코프에서 찾아라.
* 없으면 지정해준 범위 내에서 찾는다.
* console out. console in
* c out c in 


### 인스턴스와 입출력 흐름 

인스턴스의 사전적 의미는 예시 혹은 경우

* 사람 철수, 영희;
  * 철수와 영희는 각각 사람이라는 형식에 대한 인스턴스
* 미인 전지현
  * 전지현은 미인이라는 개념의 예시
* int a
  * a는 int 형식에 대한 인스턴스이다.
* string strData;
  * strData는 string 형식에 대한 인스턴스이다.

### std::out

`cin` , `cout`

### 변수의 선언 및 정의

* int a = 10;
  * 이와 같은 형식은 C언어변수선언및 초기화, 호환가능
* int a(10);
  * cpp 스타일
  * c++ 초기화를 컨스트럭터가 한다. 이러한 클러스 인스턴스 객체에 초기화를 하는 녀셕, 컨스트럭터 맴버함수를 불러야하는데
  * int a 라는 클래스에 
```
int a = 1;
int b = a;

int a(1);
int b(a);
```
### auto

cpp 11에서 새롭게 정의된 오토

```
int a = 10;
int b(a);
auto c(b);
```
* 초기값의 형식에 맞춰 선언하는 인스턴스 형식에 ...
* b에 의해서 결정되는 타입.
  * 모호성 증가.

### new와 delete 연산자

new는 생성(동적할당), delete는 소멸(해제)연산자
* new 에멀록 몰록 / delete 프리
* 형식 *변수이름 = new 형식;
  * 형식에 대한 인스턴스 하나(한개)를 동적생성한다. 내부적으로 대상형식의 생성자를 호출
* delete 변수이름
  * 뉴연산자로 동적할당한 것은 반드시 delete로 ㅅ삭제, 내부적으로 대상 형식의 소멸자를 호출
* 형식 *변수이름 = new int[요소개수]
  * 여러 인스턴스 동적생성할 때는 배열 ..,
* delete[] 변수이름
  * 배열로 생성한 것은 반드시 배열로 삭제해야 한다.

### 참조자 형식

형식 &이름 = 원본 인스턴스;

참조자 형식은 포인터와 구조적으로 비슷하고 반드시 선언과 동시에 초기화해야한다.


```
int i = 100;
int *pi;
pi = &i;
```

```c
int const * pi // * pi 값을 못바꾼다는 말.
int * const pi // pi 값을 못바꾼다는 말.

pi = &i;
```

데이터 타입 없애고 const 목적어가 누군지 생각해라.

*pi 고 pi ek. 


타입 이름 초기화값

pi 이름 pi

* `int* pi = &i`
* `int *pi = &i`

레퍼런스, 엘리어스, 

이름표 하나를 더 붙인다.

int nData = 10;
int &ref = nData;

ref 라는 이름표하나가 더 붙는 것ㅇ다.

주소는 포인터상수.

1차원포인터 변수, 1차원포인터 상수

int *pnData = &nData

*pnData = 30;

### 

형식 &이름 = 원본 인스턴스;

매개변수가 참조자면 호출자 코드만으로는 맥배개변수

레퍼런스, 자기가 직접 엑세스

```
void testfunc(int &rParam)
{

}

int main(v..)
{
  int data = 0;
  testfunc(ndata);
}
```

### 


스텍에 새로 생성되는 애들이 아니다.



### r-value 참조자

* 형식 &&이름 = r-value
* 연산의 임시결과는 상수이며 보통 이 임시결과에 대해 r-value 참조를 선언한다.

r-value 레퍼런스, 

* 가운대 어사인
* 오른쪽 알벨류 값을 주는 녀셕, 상수, 변수
* 왼쪽 엘벨류 변수
* && 하나 더 있으면 
* & (똑가틍 엘리어스가 된다. 에서) +5
* 연산결과에 대한 다이렉트 접근 하겠다.
* 결과 값을 result 가 가지고 있는 스토리지에 엘벨류에 카피해서 넣겠다. 계산값 리턴 그걸 직접 가리킨다. 그 뒤에 

```
산술연산으로 만들어진 임시객체에 대한 알벨류 참조
int &&rdata = nInput +5;
함수반환으로 만들어진 임시 객체에 대한 알밸류 참조
int &&result = TestFunc(10);
값을 변경할 수 있다
result += 10;
```

### 범위 기반 for 문
for auto 요소변수: 배열이름) 반복구문; - 반복구문
반복횟수는 배열 요소 개수에 맞춰 `자동`으로 결정

초기화 값의 클래스로 인스턴스 타입 지정.


각 요소의 값을 엔에 복사

&
엔은 각 요소에 대한 참조이다


c++ 

복사가 일어나지 않는다

c 에서 말하는 콜바이 레퍼런스가 바로 이거다 c 도 주소 카피가 일어난다.

###

### 2정

* 디폴트 매개변수
  * 기본값을 정해서 함수 이름만 스면 함수를 호출
* 다중정의
  * 이름은 같지만 매개변수 구성이 다른 함수의 정의.
  * 씨에서 없는 씨플플 적인
* 인라인 함수
  * 함수의 메크로의 장점
* 네임스페이스

### 디폴트 매개변수

### 함수 다중 정의

>굉장히 중요

이름이 같은 함수를 여러번 정의하는 분법

객체지향 특지 ㅇ4개 
* 상속, 유전 엄마아버지 자식, 부모꺼 받을 수 있는
* 인캡슐레이션, 뭔가내용이 감춰있는, 뭔가 있는 밖에서 모르는
* 다중정의 폴리모피즘
* ㄹ

펑션 오버로딩,
* 이름이 같은 함수를 여러 번 정의하는 문법
* 이름은 같더라도 매개변수 구성은 다르게 선언 및 정의해야 한다.
  * 이름이 같더라도 뒤에 나오는 알규먼트가 다르면 다른 함수
  * 이름이 같은 함수가 여러 개가 있을 수 있다.
* 디폴트 매개변수 문법과 조합됐을 때 대상 함수 식별에 대한 *모호성 발생할 수 있으므로 주의*해야한다.
* 함수 템플릿으로 대체할 수 있다.

### 함수탬플릿

template <typename T> 함수선언 및 정의
* 자료형에 대해 의존성이 없는 함수를 정의하는 문법
* template <typename T> 에서 T는 자료형이다.
* 템플릿은 일종의 틀이며 판화를 인쇄하느 것처럼 함수를 인쇄하기 위한 원본이다.

```cpp
template <typename T>
T add (T a, T b)
{
  return a+b
}

int main()
{
  std::cout << add(3,4) << std::endl;
  std::cout << add(3.3,4.4) << std::endl;
}
```

### 인라인함수

컴파일러 케시 하지 말고 메모리에서 

* const volatile

컬러파이어? 

독하게 시작하는 c 프로그래밍 15장 변수와 상수  고급이론 강좌

나갔다 오면 시간들잖아. 

volatile 

컴파일러 최적화 삭제한다. 컴파일은 메모리와 씨피슈 관계 만 생각하지만 바귄 값이 올라 올 수 있다. 온도계는 아까값 지금깞 다를 수 있는데 또 가져와 그 걸 칼질해서 못하게 했는데 그 값은 더이상 유효하지 않아. 아까 읽어온 값은 날라갔어 volatile. 휘발됐어. 컴파일러야 계속 나가서 가져와. volatile 임베디드.




# 클래스

메서드, 자바용어, 씨피피는 함수

리턴타입이 없다.



# 오늘 과제

>**오늘 과제**



---
[다시 # week 2 index 로](../w02.md)

[다시 # 전 과정 main 으로](../../README.md)
