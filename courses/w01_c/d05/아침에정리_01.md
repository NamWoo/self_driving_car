이거와
```c
int *(*p);  // 반환값을 저장할 포인터
//자료형이 정수형 포인터인, 포인터 변수 p

int (*  *p);  // 반환값을 저장할 포인터
//자료형이 정수형인, 이중포인터

int **p;
??

(int *(***p);  // 반환값을 저장할 포인터

int ***p;  // 반환값을 저장할 포인터
```



```c
int* p;  // 반환값을 저장할 포인터
```
이거는 
```c
int* sum (int a, int b);  // 주소를 반환하는 함수 원형
```
같다.



---

286 부터 다시 정리

```c
int a; // a의 주소가 100 일 때
&a + 1 = 100 + (1 * sizeof(int)) = 104

int ary[] // ary 주소가 100일 때
*(ary+1) = 100 + (1 * sizeof(int)) = 104 = ary[1]
```
```c
int ary[3]
int *pa = ary

sizeof(ary) //12바이트로 배열 전체 크기
sizeof(pa) //4바이트로 포인터 하나의 크기

포인터는 그 값을 바꿀 수 있지만 배열명은 상수이므로 값을 바꿀 수 없다.

pa = pa + 1  // 가능, 포인터에 +1 증가 
ary = ary + 1  // 불가능, 배열에 +1 증가, 상수이므로 안됨

//포인터 pa가 변수이므로 값을 바꿀 수 있다.
//배열명 ary 주소 상수로 자신의 값을 바꿀 수 없으므로 포이터와 같은 코딩방식이 불가능
```
```c
*(pa++)  // 포인터가 가리키는 배열 순번 증가, 다음 배열로
*(++pa)  // 포인터가 가리키는 배열 순번 증가, 다음 배열로
```
```c
++(*pa)  // 포인터가 가리키는 배열 값이 증가, 값의 증가
*(pa)++  // 
```

```c
// 포인터의 뺼셈과 관계 연산
// 포인터 - 포인터는 (값의 차 / 가리키는 자료형의 크기)
pb - pa -> (40 - 32) / sizeof (int)  // 8 / 4 = 2
```
```c
// 배열입력
int ary[5]







