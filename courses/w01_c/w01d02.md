***1주차 2일짜 20190514 수업***

***20190514 마지막업데이트***


# Week 1 - Day 2 - C

>**별딱지! 요약 오늘 중요한거 정리**
>>* 자동 형변환 - 작은걸 크게  
>>* 강제 형변환(케스팅)
>>* `double res;`
>>* `a = (int)res;` 이런 식으로
> 
>>* 조건연산자
>>* `b = (a > 15) ? a+1 : a-1;`
>>* `(a > 15)? (b = a+1):(b = a-1);`
>
>>if든 else든 중괄호를 생략하면 컴파일 할 else가 if 바로 밑으로 붙어 버린다.
>
>>* `int ary3[] = {1, 2, 3};` 실무에서 많이 보이는! 
>>* 컴파일러가 알아서 크기에 맞게 배열크기를 조절해준다.
>>* ***배열명 자체가 주소다***
>
>>* `%u` 를 `%x` 로 바꿔도 된다.
>>* `%x` 16진수로 찍어라. 라는 의미
>
>>* 방법1
>>* b = (a > 15) ? a+1 : a-1;
>>* 방법2
>>* (a > 15)? (b = a+1):(b = a-1);




### 4.1.5 관계연산자 106p  

>ex 4-5

```c
	res = (a > b);                 // a가 b보다 크지 않으므로 결과값은 0
	printf("a > b : %d\n", res);
```

### 4.2.1 형변환 연산자

116p 별딱지

C에선 딱 두 가지
1. 자동형 변환
2. 강제형 변환 (casting)
* C++에선 더 있다.



>ex 4-8
```c
#include <stdio.h>

int main(void)
{
	int a = 20, b = 3;
	double res;

	res = ((double)a) / ((double)b);      // a와 b의 값이 실수형으로 변환
	printf("a = %d, b = %d\n", a, b);
	printf("a / b의 결과 %.1lf\n", res);

	a = (int)res;                         // res의 값에서 정수 부분만 추림
	printf("(int) %.1lf의 결과 %d\n", res, a);

	return 0;
}
```
#### 강제형변환
```c
double res;
a = (int)res;
```
* **res는 `double`을 가지고 태어났지만**
* **`(int)res` 로 인해 강제 형변환**


#### 자동형변환

***형변환 연산자를 사용하지 않아도 데이터의 형태가 자동으로 바뀌기도 합니다.*** -> 자동형변환

* 컴파일러가 알아서, 우리가 하는게 아님
* 컴파일 과정에서 알아서 자동으로 변환
* 작은걸 크게


>기습질문 나에게
```c
int i= 10;
int n= 3;
double result

result = i/n

%lf result
// result 는 뭘까?
```
```
나의 대답은 3.3333? 멍청아!
'/' 몫만 취해야지!
3 어!? 근데 ... double 8비트?
3.00000000  ??
답은 3.0 
자동형변환 이기 때문에!!!
```

> table 4-5 119p 복합대입 연산자
> 
|복합대입 연산자|동일한 연산식|
|:---|:---:|
|a += b|a = a + b
|a -= b|a = a - b
|a *= b|a = a * b
|a /= b|a = a / b
|a %= b|a = a % b


### 4.2.5 조건연산자

> ex 4-12
```c
#include <stdio.h>

int main(void)
{
	int a = 10, b = 20, res;

	res = (a > b) ? a : b;         // a와 b 중에 큰 값이 res에 저장
	printf("큰 값 : %d\n", res);

	return 0;
}
```

```c
int a = 10, b;

// 방법1	
b = (a > 15) ? a+1 : a-1;
// 방법2
(a > 15)? (b = a+1):(b = a-1);
```

### 4.2.6 비트연산자

***비트연산자는 데이터를 비트로 정확히 표현할 수 있는 정수형에만 사용할 수 있습니다.***

|||||
|:---:|:---|:---:|:---|
|0000|0|1000|8
|0001|1|1001|9
|0010|2|1010|a
|0011|3|1011|b
|0100|4|1100|c
|0101|5|1101|d
|0110|6|1110|e
|0111|7|1111|f


>table 4-6 별딱지

* `~` 낫! 뒤집는거
* `<<` 쉽으트 는 왼쪽꺼 사라지고 오른쪽은 0으로 채우고




스팩
샘플런


# 5 if

if든 else든
***실행할 문장이 두 문장 이상이면 반드시 중괄호로 묶어야 한다.***


```c
	if (a > 0)
	{

	}
	else if (a == 0)
	{

	}
	else
	{

	}
```

* if문은 연산 로드가 심하다 
* 그래서 결과값을 내고 스위치 케이스로! 최적화할 수 있다.

### 5.2.3 else 결합문제

***중괄호를 생략하면 컴파일러는 전혀 다른 구문으로 해석***

>* 중괄호를 생략하면 컴파일 할 else가 if 바로 밑으로 붙어 버린다.
>* 그래서 이중 if시에 if 내부 if에 붙어버리게 된다
>* 뎅글리엘스? 논리에러, 런타임 에러

### 5.2.4 switch ~ case문

>***조건식은 정수식만 사용하며 기본적으로 case는 break 포함합니다.***

>***break는 필요에 따라 생략할 수 있습니다.***

>기습문제

```c
int s=5, tot=0;
switch(s){
	default: tot = tot+1;
	case1 : tot = tot+2;
	case2 : tot = tot+3;
	case3 : tot = tot+4;
}
printf("%d\n", tot)
```
```
답은 10. break가 없기 때문에! tot가 모두 더해져서 10. 또 디폴트가 위에 있다.
```


# 6 반복문
## 6.1 while, for, do ~ while

`while (a < 10) `

### 6.1.2 for문

그래도 그나마 몇번돌지 정해진 for문

`for(i=0, i<3; i++)`
* 초기식 - 딱 한번만, 변수를 초기화할 때
* 조건식
* 증감식
for(초기식)

### 6.1.3 do ~ while 별딱지

while하고 조금 다르다. 그래서 별딱지

* while은 조건에 맞지 않으면 안으로 아예 들어갈 수 없는데
* do while은 먼저 실행된 뒤에 조건을 확인한다. 
  * 고로 최소1번은 실행할 수 있다.


> ex 6-4 중첩반복문

바깥포문 1개에 안에 포문 1바퀴

### 6.2.2 break 와 continue 분기문 

>별딱지 5개. 별 5개. 경험자의 충고

***break는 조건문이 아니라 반복문을 빠져나오는 것이다.***

자기하고 가장 가까운 반복문으로!

```c
for (i = 1; i <= 10; i++)
{
	sum += i;
	if (sum > 30) break;
}
printf()
```


***`countinue` 만나면 뒤에 이어지는 다음 반복문은 제끼고 다음 반복문(뽀문)으로 이동***


>기습문제  
>C Programmin이 몇번 출력될까?

```c
#include <stdio.h>

int main(void)
{
	int i;
	while(1)
	{
		for(i=1; i<=5; i++)
		{
			if(i%3==0) continue;
			printf("C Programming... \n");			
		}
		if(i==5) break;
	}
	return 0;
	
}
```
```
정답은: 무한대
```








```c
#include <stdio.h>

int main(void)
{
	int i;
	while(1)
	{
		for(i=1; i<=5; i++)
		{
			if(i%3==0) continue;
			printf("C Programming... \n");			
		}
		if(i==5) break;
	}
	return 0;
}


```

```
countinue에서 다음 것으로 바로 넘어갔으니까 break를 넘어가버린다. 6으로 넘어갔으니 그래서 무한대가 도니다.
```


196 도전 1


# 7 함수
### 7.1.1 함수정의 201p

1. `함수명` : 함수의 기능에 맞는 이름은 무엇인가?
2. `매개변수` : 함수가 기능을 수행하는데 필요한 데이터는 무엇인가?
3. 함수가 수행된 후의 결과는 무엇인가?

```c
int a 10, b 20;
int add(int x, int y)

int //반환형
add //함수명
(int x, int y) // 매개변수2개 (=파라메터)
return  //반환형
```

지역변수의 숙명, 지역변수는 함수가 호출될 때 블럭 안에서 생성되고(스텍에 가서) 나오면서 소멸.


***함수의 선언은 함수의 원형에 세미콜론(;)을 붙인다.***

프로토 타입을 선언 `int add(int x, int y)`
* add는 컴파일러야 함수야 밑에 나올꺼야 함수의 원형

`void add(void)`  
`void` 반환값도 없고 매개변수도 없는

정수형 변수 2개의 주소를 받고 주소를 리턴하는

```c
int * add (int *x, int *y)
int (*fp[3]) (int *x, int *y)
```

함수포인트변수배열








### 7.1.3 함수선언

한거

> table 7-2 별딱지 2개

* 매겨변수가 없는 경우
* 반환형이 없는 경우
* 매개변수와 반환형이 모두 없는 경우

#### 매개변수가 없는 것
```c
res = get_pos();               // 함수 호출, 반환값은 res에 저장
```
`void`

#### 반환형이 없는 것
```c
print_char('@', 5);            // 문자와 숫자를 주고 함수 호출
```


#### 매개변수와 반환형 모두 없는 경우

```c
print_line();             // 함수 호출
```


### 7.2.4 재귀호출 함수

recursive call function

* 코드라인 수를 획기적으로 줄일 수 있다.
* 오버헤드에 걸린다.(속도가 느려질 수 있다.)

```c
#include <stdio.h>

void fruit(void);      // 함수 선언

int main(void)
{
	fruit();           // 함수 호출

	return 0;
}

void fruit(void)       // 재귀호출 함수 정의
{
	printf("apple\n");

	fruit();           // 자신을 다시 호출
}
```

무한적으로 자기가 자신을 호출하는.

하지만 탈출할 수 있는 방법

```c
	if (n == 3) return;  // 호출 횟수가 3이면 반환하고 끝낸다.
```


***재귀호출 함수는 반복 고리를 끊을 수 있는 조건식을 반드시 포함해야 한다.***

재귀호출의 2단계
* 감아 들어가는 단계
* 풀고 나오는 단계





>기습문제

`void func(int, char);`
1. return 30
2. return; 
3. return 'a';
4. return 3.4;

답2




# 8 배열

같은 자료형을 여러번 사용한다? 배열!

* 배열 
* 연산자
* 스키드?

```c
#include <stdio.h>

int main(void)
{
	int ary[5];                // int형 요소 5개의 배열 선언

	ary[0] = 10;               // 첫 번째 배열 요소에 10 대입
	ary[1] = 20;               // 두 번째 배열 요소에 20 대입
	ary[2] = ary[0] + ary[1];  // 첫 번째와 두 번째 요소를 더해 세 번째 저장
	scanf("%d", &ary[3]);      // 키보드로 네 번째 요소에 입력

	printf("%d\n", ary[2]);    // 세 번째 배열 요소 출력
	printf("%d\n", ary[3]);
	printf("%d\n", ary[4]);    // 마지막 배열 요소는 쓰레기값

	return 0;
}
```
```c
int ary[5];
// 인트형 배열 
// 배열이름은 ary
// 배열 크기는 20바이트
// 인트 4바이트 배열요소 5개 그래서 배열크기 20바이트
// 배열첨자는 0부터 시작
```

*인트 4바이트 배열요소 5개 그래서 배열크기 20바이트!*

### 8.1.2 배열 초기화

`int ages[5];` 선언만

***배열 요소의 수보다 초기화 값이 적으면 남은 기억공간은 `0`으로 초기화된다.***

`int ages[5]={1, 3}` 선언과 초기화 동시

***왼쪽에서 차례로 초기화 되고 남은 배열요소는 모두 0으로 채운다.***

***중괄호를 사용한 배열의 초기화는 선언할 때 최초 한 번만 가능하다.*** 별딱지 

> ex 8-2 별딱지3개
```c
	int ary1[5] = {1, 2, 3, 4, 5};               // int형 배열 초기화
	int ary2[5] = {1, 2, 3};                     // 초깃값이 적은 경우
	int ary3[] = {1, 2, 3};                      // 배열 요소 개수가 생략된 경우
```

`int ary3[] = {1, 2, 3};` 실무에서 많이 보이는! 

컴파일러가 알아서 크기에 맞게 배열크기를 조절해준다.


>ex 10-1 284p
```c
#include <stdio.h>

int main(void) 
{
	int ary[5] = {10, 20, 30, 40, 50};

	printf("배열명 자체의 값 : %u\n", ary);
	printf("첫 번째 배열 요소의 주소 : %u\n", &ary[4]);
	printf("배열명이 가리키는 요소의 값 : %d\n", *ary);
	printf("첫 번째 배열 요소의 값 : %d\n", ary[0]);

	return 0;
}
```
***배열명 자체가 주소다***

* `%u` 를 `%x` 로 바꿔도 된다.
* `%x` 16진수로 찍어라.


```c
	for (i = 0; i < 5; i++)         // i가 0부터 4까지 다섯 번 반복
	{
		scanf("%d", &score[i]);     // 각 배열 요소에 성적 입력
	}
```
포문하고 배열은 


오늘 꼭 복습할 내용
* 함수호출
  * >책을 안보고 3개의 정수를 입력 받아 변수에 저장한 뒤에 total 로 넘겨받아서 그 3개에 대한 합을 리턴해서 다시 반환해서 리턴 값이 있는 함수, 책을 보지 않고 짜져야!
* 함수복습
* 배열 !! 배열 !! 배열 !! 선언 !! 초기화 !!
  * >포문 5정도 잡고 배열값 출력 또는 입력!



>ex 8-4 별딱지 4개
```c
int score[5];
cnt = sizeof(score) / sizeof(score[0]);  // 배열 별딱지 4개
```
```c
sizeof(score) // 배열 전체, 배열명
sizeof(score[0]) // 배열 원소
```

>랭귀지는 절대 눈으로! 배우면 안된다!



# 오늘 과제

>**오늘 과제**
>>* 코드풀이
>>* 연습문제 3번 237 / 해답은 238
>>* 코드풀이 제출
>>* 도전실전예제 1채점, 3로또
>>* 2일차 워크샵 달력 197 도전3 달력










---

[다시 main 으로](../../README.md)
