***1주차 3일짜 20190515 수업***

***20190515 마지막업데이트***


# Week 1 - Day 3 - C


>**별딱지! 요약 오늘 중요한거 정리**
>>* ***변수 함수 다 자기 고유 주소 가지고 있다.***
>>* ***주소는 변수가 할당된 메모리 공간의 시작 주소를 사용*** -> 별딱지4개
예약실 예약 일정>?


***변수 함수 다 자기 고유 주소 가지고 있다.***
* 메모리 할당할 때 
* 주소는 컴파일 시간에 딱 정해진다.
* 배열은 어제 찍어보니 주소가 찍히고 그래서 상수


---


포인터부터 시작

# 9 포인터 254p 

* 문자를 저장하고 싶다? 캐릭터변수 사용!
* 긴 이름을 저장할 때 관련 자료형 따로 없으니 배열을 만들어서 저장해야한다.  
***주소를 저장하려면 포인터를 가지고 해야한다***




### 9.1.1 주소연산자 (&) 엠퍼센드 별딱지 1개

***주소는 변수가 할당된 메모리 공간의 시작 주소를 사용*** -> 별딱지4개

* `&` 주소연산자
  * `&` 항상 주소를 나타낸다.
* `&a` a의 주소

>ex 9-2 257p typing 해봐

```c
#include <stdio.h>

int main(void)
{
    int a; // 일반변수 선언
    int *pa; // 포인터 선언

    pa = &a; // 포인터에 a의 주소 대입
    *pa = 10; // 포인터로 변수 a에 10 대입

    pritnf("포인터로 a값 출력 : %d\n", *pa);
    pritnf("변수명으로 a값 출력 : %d\n", a); // 변수 a 값 출력

    return 0;
}
```

결과
```
포인터로 a값 출력 : 10
변수명으로 a값 출력 : 10
```


***포인터변수는 무조건 4byte*** ->32비트

34비트에서는 8바이트 앞으로는 32비트 4 기준

* 정수형 포인터변수
* 문자형 포인터변수
* 구조체  포인터변수

많은데 무조건 4바이트.

\** 포인터에 포인터 \***3중포인트

**얘도 4 *** 얘도 4

***포인터 변수는 주소만 먹고 산다!!***

포인터 변수는 
1. ***주소***
2. ***가리킨다***
3. 유식하게 `참조`한다 refference

* pa 주소 
* \* 값 그래서 그 주소의 값 *pa


포인터는 그림으로! 

***포인터 pa는 변수 a를 가리킨다***

***포인터가 가리키는 변수를 사용할 때는 간접참조 연산자(*)를 사용한다***  아스테리스크



바로 들어갈 수없으니 걔를 참조해서 간접. 주소를 바꿀 수 없으니.

주소를 써먹고 싶어서 이 녀석을 만들었다. 참조해서 가라!


* ** 이중은 포인터변수만 먹고 산다
* *** 삼중은 이중포인터만 먹고 산다

이중포인터배열
삼중포인터배열 char ***cpp = cp;



### 9.1.4 const를 사용한 포인터

***const 는 상수화***

변수에 const 쓰면 상수처럼 쓰게 된다. 주소 참조할 때 이런 경우가 있다.


* 주소는 상수고 그래서 포인터변수가 필요하다.
* 주소를 직접 갈 수 없다.

```c
int a = 5;

100 = 5;
```
이건 불가능하다.  `100`이라는 주소에 5를 넣고 싶은데 `100`은 상수기에 불가능하다.


뭐하러 이짓을해?
```c
int a = 5

int *pa

pa = &a;

*pa =5
```
275 명퀘한 해답

```c
void swap(void) {}
int temp;
temp =a;
// 이건 오류!! 내부에 a,b 
```

```c
void swap(int *a,) {}
```
콜바이벨류! 값만 복사
콜바이레퍼런스! 주소 복사 

남의 방에 선언된 값을 바꿀 수 있는 강력한!!

* a와 b선언은 메인에 되어 있다.
* swap함수에 a와 b 선언은 없다.
* 변수의 스코프 영역과 일맥상통
* 함수 안에 있는 변수는 함수 안에서만

```c
//267p
int a, *pa, *pb
pa = pb = &a;
```

***모든 주소와 포인터는 가리키는 자료형과 관계없이 크기가 같다***

가리키는 자료형에따라 달ㄹ라질수 있다.

케릭터 포인터변수는 케릭터만 가리킬수 있다.
char *p
int *p
double *p

>ex9-5 269p 
```c
	char ch;
	int in;
	double db;

	char *pc = &ch;
	int *pi = &in;
	double *pd = &db;

	printf("char * 포인터가 가리키는 변수의 크기 : %d\n", sizeof (*pc));
	printf("int * 포인터가 가리키는 변수의 크기 : %d\n", sizeof (*pi));
	printf("double * 포인터가 가리키는 변수의 크기 : %d\n", sizeof (*pd));

    //출력은 1, 4, 8
```


포인터에서는 좌항과 우항이 같아야 한다. 그래서 

* (int) //정수형으로 캐스팅
* (int *) //정수형 주소로 캐스팅

```c
int add(int a, int b) // 반환형이 정수
int* add(int *a, int *b) // 반환형이 정수형 주소
```
***정수형 주소를 매개변수로2개 넘겨받고 정수형 주소를 반환하는 add***


### 9.2.4 포인터가 필요한 이유 272p


$lim$x가 무한대로 가는!


>변수를 사용하는 가장 쉬운 방법은 이름을 쓰는 겁니다. 포인터를 사용하려면 추가적인 변수 선언이 필요하고 각종 연산을 수행해야 합니다. 따라서 포인터를 의도적으로 모든 경우에 사용할 필요는 없습니다. 따라서 ***임베디드 프로그래밍을 할 때 메모리를 직접 접근하는 경우나 동적 할당한 메모리를 사용하는 경우 포인터가 반드시 필요합니다.***

2450 samsung arm 2450 samsung arm
차량용 arm코어



동적할당

스텍에 생긴다 char 

안에 있는 애들은 함수를 벗어나면 사라진다.

메모리좀 쓰려해 근데 다 사라져?

리눅스 thread 전역변수 공유

뮤텍스 싱가포? 

전역변수로 다 때려? 동기화의 문제가 생긴다.

그래서 heap 영역

동적할당한 메모리 heap
멜롭하면 heap에 가서 저장, 빠져나가도 저장, 안 없어진다. 동적할당.

이때 포인터변수를 사용. 
c 배우면 깊게 배울수록 좋은게 많다.

>9-7 273p
>>***콜바이레퍼런스 바꿀 수 있다!***
>>
>> 콜바이레퍼런스에는 포인터변수가 존재한다!!

>9-8 275p 
>>내부에 a,b 정의 없다. 그래서 컴파일부터 오류!

>9-9 276p 
>>콜바이벨류! 변경할 수 없지만 불러올 수는 있다.

281 도전3번 조금 어려울 수 있다.


```c
#include <stdio.h>

void rotate(int *pa, int *pb, int *pc);

int main(void)
{
	int a=1, b=2, c=3;
	int i, j, k;
	int flag;
	
	printf("%d %d %d", a, b, c);
	while(1)
	{
		scanf("%c", &flag);
		if(flag != 10)
			break;
		
		
		rotate(&a,&b,&c);
		printf("%d %d %d", a, b, c);
	}	
	return 0;
}


void rotate(int *pa,int *pb, int *pc){

int temp;

temp = *pa; //a 
*pa = *pb; //b = a 
*pb = *pc; //c = b
*pc = temp; //a = c

}
```




# 10 배열

### 10.1 배열과 포인터의 관계

>ex 10-1 예전에 해본거
***배열은 주소! 상수는 변경할 수 없다. ***

### 10.1.2 배열명으로 배열 요소 사용하기

주소는 정수처럼 보이지만 자료형에 대한 정보를 갖고 있는 특별한 값입니다. 따라서 연산을 자유롭게 할 수없도고 정해진연산마 ㄴ가능합니다. 정수 덧셈이 대표적인데, 다음고 가이 독특한 방식으로 수행됩니다.



주소 100 일때 &a + 1 이건 101? 아니다.

268p

`100 + (1*sizeof(int)) -> 104`




int *p; // 포인터 변수

int arr[3]; //배열의 포인터표현
*(ary + 0) = 10;
*(ary + 1) = 10;

\* 값? 가르킨다. 

포인터!가 아니다! 값이다.


289

***배열요소 표현식 <-> 포인터 연산식***  
***`ary[1] <-> *(ary+1)`***

290
10-3

별딱지 5개 !!!!!!!


배열저장 6번 배열시작주소 포인터변수 pa에 저장
포인터변수를 변수처럼 사용

이건 고민할것없이 11장 7번에 4번


### 10.1.4 배열명과 포인터의 차이 

포인터가 배열명처럼 쓰이기는 하지만 서로 다른 점이 더 많다.

>ex 10-4 별딱지3개

***pa++***
증감연산자
단항연산자

포인트변수도 크기만큼 증가. 더블이면 8바이트씩.



>기습문제
```
1. 다음과 같은 배열 선언에 있어 각 요소 및 그 요소의 초기값이 무엇인지 적어보세요.

int array[3] = {10,20};

array[0] // 10 int
array[1] // 20 int
array[3] // 0 int


>10-4 296p

답이 뭘까? 8 아니다. 자료형! sizeof(int)값으로 나눠서 2!
아니다 2!

서현우 바이블

한빛미디어

언어 자료구조 알고리즘 딱 바이블! 




같은 포인터 변수가 여려개있으면 포인터배열

```


>기습문제
```c
int main(void){
	char *prt[]={"red","orange","pink","white","blue","brown","black","gray"};
	
	printf("%c\n",**prt); //r
	printf("%s\n",prt[1]); //orange
	printf("%s\n",prt[1]+3); //nge
	printf("%c\n",*(*(prt+1)+1)); //r
	printf("%c\n",(*(*(prt+2)+1))); //i
	printf("%s\n",prt[3]+2); //ite	
}
```


배열명을 사용한 배열표현
배열명을 사용한 포인터표현
배열명은 저장한 포인터표현
배열명은 저장한 배열표현





/s 널문자가 나올떄까지 찍는거


트롬 디오스 휘센 옵티무스

sp[0]
*sp+1



>ex 10-6




305p 10-7 조금 다른게 있다 캐치해봐라


17매개변수2개 size




배열


~여기까지 배열 다시 정리 필요

# 11.1 문자열 정말 중요하다. 별딱지5개

하나를 고르라면 이게 우선이다?




## 11.1.3
> ex 11-3 공백이나 제어문자의 입력 타이핑해봐 321p


```c
#include <stdio.h>

int main(void){
    char ch1, ch2;
    scanf("%c%c", &ch1, &ch2); // 두개의 문자 연속 입력
    printf("[%c%c]", ch1, ch2); // 입력된 문자 출력
    return 0;
}
```



***%c 변환문자는 공백문자(space), 탭문자(tab), 개행문자(enter)도 입력합니다.***

스켄f의 특징이다. 엔터 공백 도 입력으록 간주한다.


11-4 325 제일 위에
get 한문자 받는거
put 한문자 찍어주는거

330 읽어봐라

***`scanf` 함수는 사실 키보드 이전에 버퍼로부터 데이터를 입력한다.*** -> 별딱지 4개

타이핑을 하면 변수로 바로 가는 것이 아니라 버퍼로 간다. scanf 가 버퍼에서 꺼내다가 변수에 저장한다.





### 11.2.2 332p

>ex 11-6

```c
#include <stdio.h>
int main(void)
{
    int res;
    char ch;

    while(1)
    {
        res = scanf("%c", &ch);
        if(res==-1) break; // 반환값이 -1 이면 반복 종료
        printf("%d ", ch); // 입력된 문자의 아스키 코드값 출력
    }
    return 0;
}
```



>ex 11-8 엄청 중요. 할 얘기가 많다.

```c
    #include <stdio.h>
    int main(void)
    {
        int num, grade;

        printf("학번입력 :/")
        char ch;

```
엔터가 들어갔따! 

fflush없으니까


stdin 키보드

stdout 모니터

fflush !!!!


342 도전 1번 길이가 가장 긴 단어







>기습문제
* 포인터 + 정수 `sizeof(자료형)` 가능
* 포인터 - 정수 `sizeof(자료형)` 가능
* 포인터 + 포인터 안된다.
* 포인터 - 포인터 된다. 왜?

```
와있는 거에서 뒤로 가는건 된다.

와있는 거에서 더 앞으로 가는 건 미지의 영역 그래서 안된다!
```

>ex 12-1 345p 별딱지 정말정말 중요하다.
```c
#include <stdio.h>

int main(void)
{
    printf("주소값 :%p\n", "mango"); //주소값
    //
    printf("첫번째 문자 :%c\n", *"mango");
    printf("두번째 문자 :%c\n", *("mango"+1));
    printf("세번째 문자 :%c\n", "mango"[2]);
    return 0;
}
```

문자형을 주소형태로 출력? 색다른 접근법. 망고라는 문자열을 

%x %p 주소 찍는거

출력값이 주소값 00000004040000  

***문자열도 상수다.***

mango 의 첫번째
sizeof(1) mango ->a


>ex 12-2 346p 포인터로 문자열을 사용하는 방법
```c
#include <stdio.h>

int main(void)
{
    char *dessert = "apple"; // 케릭터형 포인터변수 
    //apple 찍으면 주소값
    //포인터 나타내는건 포인터
    //포인터 변수에 다시 banana 초기화
    디저트 처음에 에플
    지금은 바나나 가르킨다.

    printf("오늘 후식은 %s입니다.\n", dessert);
    dessert = "banana";
    printf("내일 후식은 %s입니다.\n", dessert);

    //한줄추가
    *(dessert + 0)= 'k'; 
    //작동중지 오류난다. 왜?
    //문자열은 상수!
    //read only ! 값을 쓸 수 없다.
    return 0;
}
```

그럼 이거 풀어봐라
*str = "efant"

*(str+4) = 'a' // 어디 상수에다 값을?
되는건 답은 2번


주소는 변할수 없다. 주소는 상수 문자열은 상수, 상수는 변환할 수 없다.

    //read only ! 값을 쓸 수 없다.

>ex 12-3 348p

349p 
***scanf 함수는 버퍼를 사용하므로 키보드로 입력한 문자열은 엔터를 칠 때 버퍼에 저장됩니다. 그 후에 scanf 함수는 버퍼에서 문자열을 가져와 배열에 저장하는데 중간에 공백문자, 탭문자, 개행문자가 이쓰면 그 이전까지만 저장합니다.*** scanf 의 한계점이다. 그래서 이걸 해결하기 위해 

>12-4 350p

그래서 문자열을 다룰 때는 `gets` 함수를 쓰는게 편하다.

***`gets`함수는 중간의 공백이나 탭문자를 포함하여 문자열 한 줄을 입력한다.***

***버터에서 개행문자를 가져오지만 배열에는 널문자로 바꿔 저장한다.*** <- 이걸 `gets`가 해준다.

하지만 버퍼의 크기보다 더 큰 입력을 줬을 때는 오류가 발행한다.

그래서 이걸 해결하기 위해 조금 더 발전된 함수 `fgets`를 쓴다.

>ex 12-5 353p fgets 함수의 문자열 입력방법

```c
char *fgets(char *str, int n, FILE *stream)
```

>질문 scanf나 fgets나 버퍼 이상 넘어가면 오류 마찬가지 아닌가요?
>>맞다. 

`fgets`의 특이한 동작특성이 있다. 그걸 알아야한다.

```c
char str[10];
```
입력시에 버퍼 이상 되는 값이 들어가면 `fgets`는 버퍼 이상 값은 버려버린다.


메모리누수, 쌓이고 쌓이면 한달, 두달 지나면 어마어마해진다. 

대전 땡땡 회사에 들어가서 전공이 컴파일러 프로그래밍 언어론쪽, 대학원 반장님이 lcd 고속능 




오늘 진도는 12.1 360p 까지 






|||||
|:---:|:---|:---:|:---|




# 오늘 과제

>**오늘 과제**
>>* 도전실전과제 313 1번
>>* 도전실전과제 342 1번
>
>>ws



삼성 S3C2450(ARM926EJ) 프로세서 탑재


---
일단 정리

* 참조가 붙어있지 않는 `int a=8;` 
  * `a` 일때 a값 8 출력 
  * `&a` 일때 a의 주소 출력
* 참조가 붙어있는 `int *aa;` 
  * 값이 선언되어있지 않을 때
    * `aa` 일때 aa값 8 출력 
    * `&aa` 일때 aa의 주소 출력
    * `aa`의 주소값 출력



과 같은 int형 변수a



---

[다시 # week 1 index 로](../w01.md)

[다시 # 전 과정 main 으로](../../README.md)





