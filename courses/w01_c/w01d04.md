***1주차 3일짜 20190516 수업***

***20190516 마지막업데이트***

# Week 1 - Day 4 - C

>**별딱지! 요약 오늘 중요한거 정리**
>>
>>

---

# 복습

* 어제 진도는 12.1 360p 까지 
* 353p 다시 설명.

>>>팁 C# L사에서 많이 쓴다.
어제 복습

* scanf 공백문자 처리, 입력 문제
* 그래서 gets 공백문자 해결 가능
* 근데 버퍼문제, 그래서 fgets 로 해결

353 354 읽고 fgets 특징 알아야 한다.


# 12 문자열
## 12.2 문자열 연산함수

>table 12-2 361p

>ex 12-8 

* "strawberry" 문자열은 문자열상수
* readonly 영역에 가서 생긴다.

```c
strcpy(str1, str2); //문자열1에 문자열2 복사
strlen(str); // 문자열 길이 반환
strcat(str1, str2); //문자열1 뒤에 이어 붙이기
strcmp(str1, str2); //비교, 크면1, 작으면-1, 같으면 0
```

>ex12-9 324 추천

아래처럼 하나씩 설명할 수 있어야 한다

* 21행 ps거 가르키는 주소의 값이 0이 아니면
  * 다시말하면 null이 아니면
  * *null이면 while문을 빠져나오는*!
* 23 ps가 가리키는 값을 왼쪽에 pd가 가리키는 값에 할당해라
* 24 주소가 증가
* 25 주소가 증가
* 27 null 넣어주고 끝내는

p366 `strncpy`는 `strcpy`와 비슷한데 5개만, 4개만 복사해줘 가능

>368p 밑에 my_strlen 과정 확인



>기습문제

```c
void main(void)
{
    static char fruit[] = "apple";
    char *ptr;
    ptr - fruit + strlen(fruit);
    while(--prt>=fruit)
        puts(ptr);
}
```
결과
```
e
le
ple
pple
apple
```
설명
```
apple\n 에서 \n을 --prt에 의해 먼저 하나 때고 시작. 
그래서 \n 다음 e부터 출력
```
배열의 배열명은 주소다! 잊지 말기!


>문자열 실습코드


### 12.2.6 문자열을 비교하는 strcmp, strcmp 함수 별딱지

string compare !
* 같으면 0
* 알파벳 순서가 str1보다 `나중에` 나오면 `1`반환
* 알파벳 순서가 str1보다 `먼저` 나오면 `-1`반환
 

>코드실습 strcmp 만들기

# 13 변수의 영역과 데이터 공유
### 13.1.1 382p

>ex 13-1 보기만

* 생략하면 오토다. 자동변수라 한다. 
* 메인함수에 a 초기화
* a 는 10 
* 함수는 블락 안에서.
* 블락을 벗어나면 사라지는 지역변수의 숙명 

>ex 13-2 보기만

* 전역변수
* 지역변수

***전역변수는 특별한 값으로 초기화하지 않아도0으로 자동 초기화됩니다.***

***전역변수와 지역변수의 이름이 같으면 지역변수를 먼저 사용합니다.***


### 13.1.4 정적 지역 변수 별딱지 2개. static 정적!!

>ex 13-4 390p

***정적지역 변수는 선언된 블록 안에서만 사용하는 전역변수와 같다.***

* 아무것도 안쓰면 auto 
* static 쓰면 전역 지역변수* 

사용법은 같은데 저장장치에 남아있는 개념.

### 13.1.5 레지스터 변수

* 전역변수
* 지역변수
* 정적변수 스테틱
* 레지스터변수
* 포인터변수

CPU 안에 레지스터가있다 그 공간을 이용한다 속도가 엄청 빠르다.

* 내공
  * 최적화
  * 정수형변수 인트에 10넣어봐?
  * 주소록 최적화
    * 레벨

**그래서 for 문안에 i `register int i` 때리면 속도 엄청 빨라진다.**


## 13.2 함수의 데이터 공유방법
### 13.2.1 값을 복사해서 전달하는 방법

값을 복사해서 전달하는 방법 = `call by value`


>기습문제
```
main함수
{

}

user 함수
{
    결과값
}
```
user함수에서 결과값을 main 함수에 돌려주려할 때 방법(c언어 기준)
1. return
   1. 결과값이 1개 밖에 안된다
      1. 구조체로 다 때려서? 하는 방법이 있다
2. 포인터변수 (메모리 주소)
   1. 결과값에 제한이 없다. 무한! 
3. 전역변수 
   1. 나쁘다. 절대하면 안된다.
   2. 쓰레드 몇개씩 막 로딩 심하다!!

이걸 `이걸 call by value` !!!

### 13.2.2 주소를 전달하는 방법

주소를 전달하는 방법 = `call by refer`

* 참조에 의한 호출
* 값에 의한 호출
* 모두 call by ref

>ex 13-8 402p

지역변수에서 나오면 소멸되기 때문에 
1. static으로
   1. stack 영역
2. 멜롭!!!  
   1. 메모리 동적할당. 
   2. heap 영역
      1. 멜롭프리????

멜롭 메모리 누수의 대표적!!!

이걸 해결하기 위한 유틸리티가 예전엔 있었는데 자바나오면서 사라졌다. 
이런 유틸리티가 `가비지컬렉션`. 

`가비지컬렉션` = 메모리를 안쓰면 알아서 지워주는 기능
* 쓰레기 수집(garbage collection 가비지 컬렉션, GC)


>도전실전예제 도전3 409p 해봐


2시까지 


# 14 다차원 배열과 포인터 배열
## 14.1 2차원 배열

>ex 14-1 413p 
* `int score[3][4]`  크기는 3x4
* for문과 딱 맞아떨어진다

>415p 읽어만 봐라. 얘는 사람이 생각하는

>416p

***2차원 배열은 1차원 배열과 같다.*** 
-> ***부분배열***

***행 초깃값 생략하면 그 행의 남은 요소는 0으로 자동 초기화 된다.***

int

***2차원 배열을 초기화한 경우 `행의 수`를 생략하고 선언한다.***

```c
int animal[5][50];
```

[5]가 [20]개

424까지

>3차원 안함

## 14.2 포인터 배열
432p 같은 포인터 변수가 여러개? ->포인터 배열

`char *pary[5];`


>p434 별딱지 3개

```c
	int ary1[4] = {1, 2, 3, 4};           // 1차원 배열의 선언과 초기화
	int ary2[4] = {11, 12, 13, 14};
	int ary3[4] = {21, 22, 23, 24};
	int *pary[3] = {ary1, ary2, ary3};    // 포인터 배열에 각 배열명 초기화
```

***포인터 변수는 주소를 가리킨다. !!***


여기부분 정리

>실습 도전1 가로세로의 합 구하기 442p

# 15 응용포인터
## 15.1

* `포인터 주소` 자체주소를 받으려면 `이중포인터`
* `이중포인터 주소` 자체주소를 받으려면 `삼중포인터`
  
>ex 15-1 446p 447p 이중포인터변수


9. a=10 주소 가리킨다
10. 포인터주소 가지고 있다

>`int *p`
>* 가리킨다 주소! 
>* int형 `변수`!

>`int* *p`
>* 가리킨다 주소! 
>* int형 `포인터변수` !

* \* 한번 참조
* \** 두번 참조하라는 의미

>ex 15-2 451p 별딱지 5개!!!! !!!!!!!!!!!!!!!!


```c
#include <stdio.h>

void swap_ptr(char **ppa, char **ppb);

int main(void)
{
	char *pa = "success"; 
    //문자열 상수, 주소는 바꿀 수 없고 상수, 포인터 변수의 역할 간접참조!
	char *pb = "failure";

	printf("pa -> %s, pb -> %s\n", pa, pb);  // 바꾸기 전에 문자열 출력
	swap_ptr(&pa, &pb);                      // 함수 호출
    //포인터변수 pa주소, success 주소가 아니라 pa 자체 주소
    //그래서 call by ref 하려면, 그래서 이렇게 이 소스의 핵심
    //동급으로 쓰면 안된다. 그래서 이중포인터 변수로 한다.
    //다시
    //포인터주소자체를 매개변수로 넘겨주면 동급으로 안되고 이중포인터변수를 써야한다.

	printf("pa -> %s, pb -> %s\n", pa, pb);  // 바꾼 후에 문자열 출력

	return 0;
}

void swap_ptr(char **ppa, char **ppb)
{
	char *pt;

	pt = *ppa;
	*ppa = *ppb;
	*ppb = pt;
}

```

>452p 중간 4줄 읽어보고 `포인터훈련2.ppt` 파일 보기

```c
char *c[]={}; //포인터 배열
char **cp[]={c+3,c+2,c+1,c}; //이중포인터 배열
char ***cpp = cp; //삼중포인터
int main() {}
```


삼중포인터


문자열은 리드온리 특정영역 산다. 

1000 1100 1200 1300 같은 곳

c는 포인터배열 4칸씩
cp도 4칸 4바이트씩
cpp는 1칸



**++cpp

*(*(cpp))



2
```c
char *fruit[]={"","","","",""};
```




>ex 15-3 454p 

```c
#include <stdio.h>

void print_str(char **pps, int cnt);

int main(void)
{
	
	char *ptr_ary[] = {"eagle", "tiger", "tiger", "lion", "squirrel"};
	// 포인터배열, 같은 형의 포인터가 여러개
	int count;
	
	count = sizeof(ptr_ary)/sizeof(ptr_ary[0]);
	print_str(ptr_ary,count);
	//포인터의 시작수가 달라졌다.  

	return 0;
}

void print_str(char **pps, int cnt) // 그래서 이중포인터로. 
//포인터배열을 받으려고 하려면 이중포인터! 사용 
{
	int i;
	
	for(i=0; i<cnt;i++)
	{
		printf("%s\n", pps[i]); 
		// 배열명으로 사용할 수 있다. 그래서 부분배열처럼 사용할 수 있다.
	}
}

```

>ex 15-5 458p
>>앞에꺼랑 다른 내용 찾아라
```c
int(*pa)[4]; // int형 변수 4개의 배열을 가리키는 배열 포인터

char *p[3]; //포인터배열
int (*pa)[4]; //배열 포인터
int(*pa)(void); //함수 포인터 //함수이름이 pa 매개변수 없고 매개변수 없고 
int * pa (void); //함수 pa 반환값이 정수형 포인터
```
>위에 중요하다 별딱지!!!
>>배열포인터 왜 중요하냐?? 2차원 배열 매개변수 같은 곳에서 받을 때 끝!!!
>
>>헷갈리는 3종 셋트
>>* 포인터배열
>>* 배열포인터
>>* 함수포인터

- 지금 시간 오후 4시

pa 라는 배열포인터변수는 2차원 배열의 시작주소! 행렬 



>기습문제 a[][4] ....

>ex 15-4

```c
	int ary[5];

	printf("ary의 값 : %u\n", ary);      // 주소로서의 배열명의 값
	printf("ary의 주소 : %u\n", &ary);   // 배열의 주소
	printf("ary + 1 : %u\n", ary + 1); 
    //sizeof 1칸 증가
	printf("&ary + 1 : %u\n", &ary + 1);    
    //&ary + 1
    //
```



>도전실전예제 도전3 482p 

지금까지 배운 내용 모두 나와있다 제출!








내일 구조체까지 진도나간다 (파일처리 빠진다.) 일주일동안 배운 내용으로 프로젝트 제출



|||||
|:---:|:---:|:---:|:---:|
|||||

# 오늘 과제

>**오늘 과제**
>>* 도전실전과제 p
>>* 도전실전예제 도전3 482p 총복습내용
>>* Workshop 4일차는 [없음]

---

[다시 main 으로](../../readme.md)




---
```c
char (*intro)[80] //케릭터형 배열포인터
char *intro[80] //케릭터형 포인터배열 포인터들로 구성된 배열

char **pint // **포인터주소 ***이중포인터 주소
```
1. 케릭터형 배열포인터 를 의미한다.
2. input 배열, ㅁㅁㄴ럼ㄴ리, ㅁㄴ럼ㄴ리ㅏ, ㅁ넘ㄴ리ㅏ 
3. 배열포인터다? 이것들의 주소, 배열명, 제일 앞 주소값 



---

[다시 # week 1 index 로](../w01.md)

[다시 # 전 과정 main 으로](../../README.md)
